//------------------------------------------------------------------------------
// <auto-generated>                                                             
//     This code was generated by a tool.                                       
//     Changes to this file may cause incorrect behavior and will be lost if    
//     the code is regenerated.                                                 
// </auto-generated>                                                            
//------------------------------------------------------------------------------
#pragma warning disable 436
#pragma warning disable 162
#pragma warning disable 1591
using System;
using Microsoft.Quantum.Core;
using Microsoft.Quantum.Intrinsic;
using Microsoft.Quantum.Intrinsic.Interfaces;
using Microsoft.Quantum.Simulation.Core;

[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"MITRE.QSD.L11\",\"Name\":\"E01_PrepareTwoTermState\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Full\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/home/ubuntu/varun/do-not-modify/L11/L11.qs\",\"Position\":{\"Item1\":31,\"Item2\":1},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":34}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"secondTerm\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":3},\"Item2\":{\"Line\":2,\"Column\":13}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"register\"]},\"Type\":{\"Case\":\"UserDefinedType\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Arithmetic\",\"Name\":\"LittleEndian\",\"Range\":{\"Case\":\"Value\",\"Fields\":[{\"Item1\":{\"Line\":3,\"Column\":14},\"Item2\":{\"Line\":3,\"Column\":26}}]}}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":3},\"Item2\":{\"Line\":3,\"Column\":11}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Int\"},{\"Case\":\"UserDefinedType\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Arithmetic\",\"Name\":\"LittleEndian\",\"Range\":{\"Case\":\"Null\"}}]}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you are given a qubit register in the |0> state and\",\" must prepare a superposition state 1/√2(|0>+|x>), where x is some\",\" integer given by the `secondTerm` parameter.\",\"\",\" # Input\",\" ## secondTerm\",\" Integer value of second term in superposition state to prepare.\",\"\",\" ## register\",\" Arbitrary-length qubit register. Note the register is little endian.\",\" For example, the three-qubit encoding of the state 1/√2(|0>+|4>) would\",\" be 1/√2(|000>+|001>).\",\"\",\" # Remarks\",\" The unit tests for this exercise include the use of the QDK's sparse\",\" simulator, which can handle large numbers of qubits for states with a\",\" small number of superposition terms. For more info on the sparse\",\" simulator, see:\",\" https://learn.microsoft.com/en-us/azure/quantum/machines/sparse-simulator\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"MITRE.QSD.L11\",\"Name\":\"E01_PrepareTwoTermState\"},\"Attributes\":[],\"SourceFile\":\"/home/ubuntu/varun/do-not-modify/L11/L11.qs\",\"Position\":{\"Item1\":31,\"Item2\":1},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":34}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"MITRE.QSD.L11\",\"Name\":\"E02_IncrementByOne\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Empty\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/home/ubuntu/varun/do-not-modify/L11/L11.qs\",\"Position\":{\"Item1\":78,\"Item2\":1},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":29}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"register\"]},\"Type\":{\"Case\":\"UserDefinedType\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Arithmetic\",\"Name\":\"LittleEndian\",\"Range\":{\"Case\":\"Value\",\"Fields\":[{\"Item1\":{\"Line\":1,\"Column\":42},\"Item2\":{\"Line\":1,\"Column\":54}}]}}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":31},\"Item2\":{\"Line\":1,\"Column\":39}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"UserDefinedType\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Arithmetic\",\"Name\":\"LittleEndian\",\"Range\":{\"Case\":\"Null\"}}]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you are given a qubit register in an arbitrary state\",\" |x> and must transform it into the state |x+1>.\",\"\",\" # Input\",\" ## register\",\" Arbitrary-length qubit register. As in the previous exercise, the\",\" register is little endian.\",\"\",\" # Remarks\",\" The unit tests for this exercise include the use of the QDK's Toffoli\",\" simulator, which essentially treats the qubits like bits and can\",\" therefore handle extremely large numbers of qubits. You can only use X\",\" and controlled X gates when running on this simulator. For more info on\",\" the Toffoli simulator, see:\",\" https://learn.microsoft.com/en-us/azure/quantum/machines/toffoli-simulator\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"MITRE.QSD.L11\",\"Name\":\"E02_IncrementByOne\"},\"Attributes\":[],\"SourceFile\":\"/home/ubuntu/varun/do-not-modify/L11/L11.qs\",\"Position\":{\"Item1\":78,\"Item2\":1},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":29}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"MITRE.QSD.L11\",\"Name\":\"E03_ImpossibleToSimulate\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Full\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"/home/ubuntu/varun/do-not-modify/L11/L11.qs\",\"Position\":{\"Item1\":98,\"Item2\":1},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":35}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"UnitType\"},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, your goal is write an operation that cannot be\",\" simulated using the full state, sparse, and Toffoli simulators, yet\",\" can be analyzed using the trace simulator in a reasonable amount of\",\" time.\",\"\",\" This is an example of quantum resource estimation, where we are\",\" gathering precise metrics of what computational resources would be\",\" required to run the operation, even if we cannot simulate it directly.\",\" Check the unit test output for the results. For more info on the trace\",\" simulator, see:\",\" https://learn.microsoft.com/en-us/azure/quantum/machines/qc-trace-simulator/\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"MITRE.QSD.L11\",\"Name\":\"E03_ImpossibleToSimulate\"},\"Attributes\":[],\"SourceFile\":\"/home/ubuntu/varun/do-not-modify/L11/L11.qs\",\"Position\":{\"Item1\":98,\"Item2\":1},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":35}},\"Documentation\":[]}")]
#line hidden
namespace MITRE.QSD.L11
{
    [SourceLocation("/home/ubuntu/varun/do-not-modify/L11/L11.qs", OperationFunctor.Body, 32, 79)]
    public partial class E01_PrepareTwoTermState : Operation<(Int64,Microsoft.Quantum.Arithmetic.LittleEndian), QVoid>, ICallable
    {
        public E01_PrepareTwoTermState(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(Int64,Microsoft.Quantum.Arithmetic.LittleEndian)>, IApplyData
        {
            public In((Int64,Microsoft.Quantum.Arithmetic.LittleEndian) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return ((IApplyData)Data.Item2?.Data)?.Qubits;
                }
            }
        }

        String ICallable.Name => "E01_PrepareTwoTermState";
        String ICallable.FullName => "MITRE.QSD.L11.E01_PrepareTwoTermState";
        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__H
        {
            get;
            set;
        }

        protected ICallable Length__
        {
            get;
            set;
        }

        protected IUnitary<(Qubit,Qubit)> Microsoft__Quantum__Intrinsic__CNOT
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__X
        {
            get;
            set;
        }

        public override Func<(Int64,Microsoft.Quantum.Arithmetic.LittleEndian), QVoid> __Body__ => (__in__) =>
        {
            var (secondTerm,register) = __in__;
#line 41 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
            var secondTermCopy = secondTerm;
#line 42 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
            var leastSigBit = (secondTermCopy % 2L);
#line 43 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
            secondTermCopy = (secondTermCopy >> (int)1L);
#line 45 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
            Microsoft__Quantum__Intrinsic__H.Apply(register.Data[0L]);
#line 46 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
            var lastOn = -(1L);
#line 47 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
            foreach (var i in new QRange(1L, (register.Data.Length - 1L)))
#line hidden
            {
#line 48 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                var b = (secondTermCopy % 2L);
#line 49 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                secondTermCopy = (secondTermCopy >> (int)1L);
#line 51 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                if ((b == 1L))
                {
#line 52 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                    lastOn = i;
#line 53 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                    Microsoft__Quantum__Intrinsic__CNOT.Apply((register.Data[0L], register.Data[i]));
                }
            }

#line 57 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
            if (((leastSigBit == 0L) && (lastOn >= 0L)))
            {
#line 58 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                Microsoft__Quantum__Intrinsic__X.Controlled.Apply((new QArray<Qubit>(register.Data[lastOn]), register.Data[0L]));
            }

#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Intrinsic__H = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.H));
            this.Length__ = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Core.Length<>));
            this.Microsoft__Quantum__Intrinsic__CNOT = this.__Factory__.Get<IUnitary<(Qubit,Qubit)>>(typeof(global::Microsoft.Quantum.Intrinsic.CNOT));
            this.Microsoft__Quantum__Intrinsic__X = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.X));
        }

        public override IApplyData __DataIn__((Int64,Microsoft.Quantum.Arithmetic.LittleEndian) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, Int64 secondTerm, Microsoft.Quantum.Arithmetic.LittleEndian register)
        {
            return __m__.Run<E01_PrepareTwoTermState, (Int64,Microsoft.Quantum.Arithmetic.LittleEndian), QVoid>((secondTerm, register));
        }
    }

    [SourceLocation("/home/ubuntu/varun/do-not-modify/L11/L11.qs", OperationFunctor.Body, 79, 99)]
    public partial class E02_IncrementByOne : Operation<Microsoft.Quantum.Arithmetic.LittleEndian, QVoid>, ICallable
    {
        public E02_IncrementByOne(IOperationFactory m) : base(m)
        {
        }

        String ICallable.Name => "E02_IncrementByOne";
        String ICallable.FullName => "MITRE.QSD.L11.E02_IncrementByOne";
        protected ICallable Length__
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__X
        {
            get;
            set;
        }

        public override Func<Microsoft.Quantum.Arithmetic.LittleEndian, QVoid> __Body__ => (__in__) =>
        {
            var register = __in__;
#line 80 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
            foreach (var index in new QRange((register.Data.Length - 1L), -(1L), 1L))
#line hidden
            {
#line 81 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                Microsoft__Quantum__Intrinsic__X.Controlled.Apply((register.Data.Slice(new QRange(0L, (index - 1L))), register.Data[index]));
            }

#line 83 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
            Microsoft__Quantum__Intrinsic__X.Apply(register.Data[0L]);
#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Length__ = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Core.Length<>));
            this.Microsoft__Quantum__Intrinsic__X = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.X));
        }

        public override IApplyData __DataIn__(Microsoft.Quantum.Arithmetic.LittleEndian data) => data;
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, Microsoft.Quantum.Arithmetic.LittleEndian register)
        {
            return __m__.Run<E02_IncrementByOne, Microsoft.Quantum.Arithmetic.LittleEndian, QVoid>(register);
        }
    }

    [SourceLocation("/home/ubuntu/varun/do-not-modify/L11/L11.qs", OperationFunctor.Body, 99, -1)]
    public partial class E03_ImpossibleToSimulate : Operation<QVoid, QVoid>, ICallable
    {
        public E03_ImpossibleToSimulate(IOperationFactory m) : base(m)
        {
        }

        String ICallable.Name => "E03_ImpossibleToSimulate";
        String ICallable.FullName => "MITRE.QSD.L11.E03_ImpossibleToSimulate";
        protected Allocate Allocate__
        {
            get;
            set;
        }

        protected Release Release__
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__H
        {
            get;
            set;
        }

        protected IUnitary<(Qubit,Qubit)> Microsoft__Quantum__Intrinsic__CNOT
        {
            get;
            set;
        }

        protected IUnitary<Microsoft.Quantum.Arithmetic.BigEndian> Microsoft__Quantum__Canon__QFT
        {
            get;
            set;
        }

        protected ICallable<IQArray<Qubit>, Microsoft.Quantum.Arithmetic.BigEndian> Microsoft__Quantum__Arithmetic__BigEndian
        {
            get;
            set;
        }

        public override Func<QVoid, QVoid> __Body__ => (__in__) =>
        {
#line hidden
            {
#line 105 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                var qubits = Allocate__.Apply(100L);
#line hidden
                bool __arg1__ = true;
                try
                {
#line 107 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                    Microsoft__Quantum__Intrinsic__H.Apply(qubits[0L]);
#line 108 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                    foreach (var i in new QRange(1L, 99L))
#line hidden
                    {
#line 109 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                        Microsoft__Quantum__Intrinsic__CNOT.Apply((qubits[(i - 1L)], qubits[i]));
                    }

#line 112 "/home/ubuntu/varun/do-not-modify/L11/L11.qs"
                    Microsoft__Quantum__Canon__QFT.Apply(new Microsoft.Quantum.Arithmetic.BigEndian(qubits));
                }
#line hidden
                catch
                {
                    __arg1__ = false;
                    throw;
                }
#line hidden
                finally
                {
                    if (__arg1__)
                    {
#line hidden
                        Release__.Apply(qubits);
                    }
                }
            }

#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Allocate__ = this.__Factory__.Get<Allocate>(typeof(global::Microsoft.Quantum.Intrinsic.Allocate));
            this.Release__ = this.__Factory__.Get<Release>(typeof(global::Microsoft.Quantum.Intrinsic.Release));
            this.Microsoft__Quantum__Intrinsic__H = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.H));
            this.Microsoft__Quantum__Intrinsic__CNOT = this.__Factory__.Get<IUnitary<(Qubit,Qubit)>>(typeof(global::Microsoft.Quantum.Intrinsic.CNOT));
            this.Microsoft__Quantum__Canon__QFT = this.__Factory__.Get<IUnitary<Microsoft.Quantum.Arithmetic.BigEndian>>(typeof(global::Microsoft.Quantum.Canon.QFT));
            this.Microsoft__Quantum__Arithmetic__BigEndian = this.__Factory__.Get<ICallable<IQArray<Qubit>, Microsoft.Quantum.Arithmetic.BigEndian>>(typeof(global::Microsoft.Quantum.Arithmetic.BigEndian));
        }

        public override IApplyData __DataIn__(QVoid data) => data;
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__)
        {
            return __m__.Run<E03_ImpossibleToSimulate, QVoid, QVoid>(QVoid.Instance);
        }
    }
}